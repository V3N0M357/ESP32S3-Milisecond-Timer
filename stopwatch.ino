// ============================================================
//  Stack size MUST be set before anything else
// ============================================================
SET_LOOP_TASK_STACK_SIZE(32768);

#define LGFX_USE_V1
#include <LovyanGFX.hpp>
#include <lgfx/v1/platforms/esp32s3/Panel_RGB.hpp>
#include <lgfx/v1/platforms/esp32s3/Bus_RGB.hpp>
#include "esp_timer.h"

// ============================================================
//  Button Pins
//  GPIO  2 = Start / Stop
//  GPIO 17 = short press → Reset | hold 2s → Set Minimum
// ============================================================
#define BTN_START_STOP  2
#define BTN_RESET       17
#define HOLD_MS         2000
#define DEBOUNCE_MS     20

// ============================================================
//  RGB Display — 1024 × 600
// ============================================================
class LGFX : public lgfx::LGFX_Device {
public:
  lgfx::Bus_RGB   _bus_instance;
  lgfx::Panel_RGB _panel_instance;

  LGFX(void) {
    {
      auto cfg = _bus_instance.config();
      cfg.panel = &_panel_instance;
      cfg.pin_d0  = 8;  cfg.pin_d1  = 3;  cfg.pin_d2  = 46; cfg.pin_d3  = 9;
      cfg.pin_d4  = 1;  cfg.pin_d5  = 5;  cfg.pin_d6  = 6;  cfg.pin_d7  = 7;
      cfg.pin_d8  = 15; cfg.pin_d9  = 16; cfg.pin_d10 = 4;  cfg.pin_d11 = 45;
      cfg.pin_d12 = 48; cfg.pin_d13 = 47; cfg.pin_d14 = 21; cfg.pin_d15 = 14;
      cfg.pin_henable = 40;
      cfg.pin_vsync   = 41;
      cfg.pin_hsync   = 42;
      cfg.pin_pclk    = 39;
      cfg.freq_write        = 12000000;
      cfg.hsync_front_porch = 8;
      cfg.hsync_pulse_width = 4;
      cfg.hsync_back_porch  = 43;
      cfg.vsync_front_porch = 8;
      cfg.vsync_pulse_width = 4;
      cfg.vsync_back_porch  = 12;
      _bus_instance.config(cfg);
    }
    {
      auto cfg = _panel_instance.config();
      cfg.memory_width  = 1024;
      cfg.memory_height = 600;
      cfg.panel_width   = 1024;
      cfg.panel_height  = 600;
      cfg.offset_x = 0;
      cfg.offset_y = 0;
      _panel_instance.config(cfg);
    }
    setPanel(&_panel_instance);
  }
};

// Global LCD pointer — allocated in setup()
static LGFX* lcd = nullptr;

// ============================================================
//  Logo — 125 × 125 px, 1-bit bitmap
// ============================================================
const unsigned char myLogo[] PROGMEM = {
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x7f,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x3f,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x1f,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x01,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x1f,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x3f,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x7f,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0x7c,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xc0,0x07,0xff,0xff,0xfc,0x3f,0xff,0xfc,0x00,0x0f,0xff,0xe0,0x00,0x1f,0xf8,
    0xff,0xc0,0x00,0xff,0xff,0xf8,0x3f,0xff,0xfc,0x00,0x07,0xff,0xe0,0x00,0x1f,0xf8,
    0xff,0xc0,0x00,0x7f,0xff,0xf8,0x1f,0xff,0xfc,0x00,0x03,0xff,0xe0,0x00,0x1f,0xf8,
    0xff,0xc7,0xfc,0x3f,0xff,0xf1,0x0f,0xff,0xfc,0x7f,0xe3,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc7,0xfe,0x1f,0xff,0xf1,0x8f,0xff,0xfc,0x7f,0xe3,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc7,0xff,0x1f,0xff,0xe3,0x87,0xff,0xfc,0x7f,0xe3,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc7,0xff,0x1f,0xff,0xc3,0xc7,0xff,0xfc,0x40,0x03,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc7,0xff,0x1f,0xff,0xc7,0xe3,0xff,0xfc,0x60,0x07,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc7,0xff,0x1f,0xff,0x80,0x03,0xff,0xfc,0x70,0x3f,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc7,0xfe,0x3f,0xff,0x80,0x01,0xff,0xfc,0x78,0x3f,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc7,0xf8,0x3f,0xff,0x00,0x00,0xff,0xfc,0x7e,0x1f,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc0,0x00,0x7f,0xff,0x1f,0xf8,0xff,0xfc,0x7f,0x0f,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc0,0x01,0xff,0xfe,0x3f,0xf8,0x7f,0xfc,0x7f,0x87,0xff,0xff,0x8f,0xff,0xf8,
    0xff,0xc0,0x1f,0xff,0xfe,0x3f,0xfc,0x7f,0xfc,0x7f,0xc3,0xff,0xff,0xcf,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xfc,0x3d,0xbb,0xbd,0xef,0x7d,0xef,0x77,0xc3,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xfb,0xfd,0x97,0xbc,0xcf,0x39,0xef,0xb7,0xbf,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xfc,0x3e,0xd7,0xbd,0x7f,0x55,0xef,0xd7,0xb1,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xbe,0x6f,0xbd,0xbf,0x6d,0xef,0xe7,0xbd,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xfc,0x7f,0xef,0xff,0xff,0xff,0xff,0xf7,0xe3,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8
};

// ============================================================
//  Layout constants
// ============================================================
#define LOGO_W      125
#define LOGO_H      125
#define LOGO_X      ((1024 - LOGO_W) / 2)
#define LOGO_Y      20
#define TIMER_TS    5
#define CHAR_W      (6 * TIMER_TS)
#define CHAR_H      (8 * TIMER_TS)
#define FRAC_DIGITS 8
#define FRAC_W      (FRAC_DIGITS * CHAR_W)
#define TIMER_CY    340
#define TIMER_TOP   (TIMER_CY - CHAR_H / 2)
#define STATUS_CY   530

// ============================================================
//  Matrix rain characters
// ============================================================
static const char MATRIX_CHARS[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&!?";
#define MATRIX_CHAR_COUNT 43

// ============================================================
//  Global timer state
// ============================================================
static uint64_t g_startUs    = 0;
static uint64_t g_elapsedUs  = 0;
static bool     g_running    = false;
static bool     g_showMin    = false;

static uint32_t g_lastSecs      = 0xFFFFFFFF;
static int      g_lastIntDotLen = -1;
static int      g_lastFracX     = 0;

// Button state — Start/Stop (debounced)
static bool     g_startBtnLast  = HIGH;
static bool     g_startBtnState = HIGH;
static uint32_t g_startDebounce = 0;

// Button state — Reset (debounced + hold)
static bool     g_resetBtnLast  = HIGH;
static bool     g_resetBtnState = HIGH;
static uint32_t g_resetDebounce = 0;
static bool     g_resetHeld     = false;
static uint32_t g_resetPressAt  = 0;
static bool     g_holdFired     = false;

// ============================================================
//  Simple LCG random (no stdlib needed)
// ============================================================
static uint32_t _seed = 12345;

static uint32_t fastRand() {
  _seed = _seed * 1664525u + 1013904223u;
  return _seed;
}

static char randomMatrixChar() {
  return MATRIX_CHARS[fastRand() % MATRIX_CHAR_COUNT];
}

// ============================================================
//  Startup helpers  (kept lean to reduce stack depth)
// ============================================================

// Draw a full screen of random green matrix characters
static void drawMatrixNoise(int textSize) {
  lcd->setTextSize(textSize);
  int cw   = 6 * textSize;
  int ch   = 8 * textSize;
  int cols = 1024 / cw;
  int rows = 600  / ch;
  char buf[2] = {0, 0};
  for (int r = 0; r < rows; r++) {
    for (int c = 0; c < cols; c++) {
      uint8_t bright = (uint8_t)(80 + (fastRand() % 175));
      buf[0] = randomMatrixChar();
      lcd->setTextColor(lcd->color565(0, bright, 0), TFT_BLACK);
      lcd->drawString(buf, c * cw, r * ch);
    }
  }
}

// Type a string char-by-char with matrix scramble effect
// Kept iterative — no recursion — to save stack
static void typewriterMatrix(const char* text, int x, int y, int ts,
                              uint16_t finalColor,
                              int scrambleFrames, int delayPerChar) {
  lcd->setTextSize(ts);
  int cw  = 6 * ts;
  int len = (int)strlen(text);
  char buf[2] = {0, 0};

  for (int i = 0; i < len; i++) {
    for (int f = 0; f < scrambleFrames; f++) {
      buf[0] = randomMatrixChar();
      lcd->setTextColor(lcd->color565(0, 200, 0), TFT_BLACK);
      lcd->drawString(buf, x + i * cw, y);
      delay(18);
    }
    buf[0] = text[i];
    lcd->setTextColor(finalColor, TFT_BLACK);
    lcd->drawString(buf, x + i * cw, y);
    delay(delayPerChar);
  }
}

// Loading bar — fills left to right over durationMs
static void drawLoadingBar(int y, int barH, uint32_t durationMs) {
  const int barX = 100;
  const int barW = 1024 - 200;

  lcd->drawRect(barX - 2, y - 2, barW + 4, barH + 4,
                lcd->color565(0, 180, 0));

  uint32_t start     = millis();
  int      lastFilled = 0;

  while (true) {
    uint32_t elapsed = millis() - start;
    if (elapsed >= durationMs) elapsed = durationMs;

    int filled = (int)((uint32_t)elapsed * barW / durationMs);
    if (filled > lastFilled) {
      for (int px = lastFilled; px < filled; px++) {
        uint8_t g = (uint8_t)(120 + (px * 135) / barW);
        lcd->fillRect(barX + px, y, 1, barH,
                      lcd->color565(0, g, 20));
      }
      lastFilled = filled;
    }
    if (elapsed >= durationMs) break;
  }
}

static void runStartupSequence() {
  _seed = (uint32_t)esp_timer_get_time();

  // Phase 1 — Matrix noise flood (1.2 s)
  uint32_t phase1End = millis() + 1200;
  while (millis() < phase1End) {
    drawMatrixNoise(2);
    delay(60);
  }

  // Phase 2 — "INITIALIZING VERSION 2.1"
  lcd->fillScreen(TFT_BLACK);
  delay(120);

  const char* initText = "INITIALIZING VERSION 2.1";
  const int   ts       = 3;
  const int   cw       = 6 * ts;
  int initW = (int)strlen(initText) * cw;
  int initX = (1024 - initW) / 2;
  int initY = 220;

  typewriterMatrix(initText, initX, initY, ts,
                   lcd->color565(0, 255, 80), 5, 40);
  delay(400);

  // Phase 3 — Flicker scatter (doesn't clobber initText row)
  {
    char buf[2] = {0, 0};
    for (int wave = 0; wave < 3; wave++) {
      for (int i = 0; i < 60; i++) {
        int col = (int)(fastRand() % (1024 / 12));
        int row = (int)(fastRand() % (600  / 16));
        if (row == initY / 16) continue;
        uint8_t bright = (uint8_t)(40 + (fastRand() % 140));
        buf[0] = randomMatrixChar();
        lcd->setTextSize(2);
        lcd->setTextColor(lcd->color565(0, bright, 0), TFT_BLACK);
        lcd->drawString(buf, col * 12, row * 16);
      }
      delay(80);
    }
  }

  // Phase 4 — READY messages
  lcd->fillScreen(TFT_BLACK);
  delay(100);

  const char* readyLine1 = "VERSION 2.1 READY";
  const char* readyLine2 = "STARTUP SEQUENCE COMPLETE";

  int r1x = (1024 - (int)strlen(readyLine1) * cw) / 2;
  int r2x = (1024 - (int)strlen(readyLine2) * cw) / 2;

  typewriterMatrix(readyLine1, r1x, 180, ts,
                   lcd->color565(0, 255, 120), 4, 35);
  delay(150);
  typewriterMatrix(readyLine2, r2x, 240, ts,
                   lcd->color565(0, 220,  80), 4, 30);
  delay(300);

  // Phase 5 — Loading bar
  lcd->setTextSize(2);
  lcd->setTextColor(lcd->color565(0, 200, 60), TFT_BLACK);
  lcd->setTextDatum(MC_DATUM);
  lcd->drawString("LOADING SYSTEM...", 512, 420);
  lcd->setTextDatum(TL_DATUM);

  drawLoadingBar(450, 24, 2000);

  // Phase 6 — SYSTEM READY
  lcd->setTextSize(2);
  lcd->setTextDatum(MC_DATUM);
  lcd->setTextColor(lcd->color565(80, 255, 80), TFT_BLACK);
  lcd->drawString("SYSTEM READY", 512, 500);
  lcd->setTextDatum(TL_DATUM);
  delay(800);

  // Phase 7 — Scanline wipe to black
  for (int y = 0; y < 600; y += 8) {
    lcd->fillRect(0, y, 1024, 8, TFT_BLACK);
    delay(4);
  }
}

// ============================================================
//  Forward declarations
// ============================================================
static void drawLogo();
static void updateTimer();
static void updateStatus();
static void handleButtons();
static void doStartStop();
static void doReset();
static void doSetMin();
static void forceFullRedraw();

// ============================================================
//  Arduino entry points
// ============================================================
void setup() {
  Serial.begin(115200);
  Serial.println("Booting...");

  pinMode(BTN_START_STOP, INPUT_PULLUP);
  pinMode(BTN_RESET,      INPUT_PULLUP);

  lcd = new LGFX();
  if (!lcd) {
    Serial.println("FATAL: LGFX alloc failed — halting");
    while (true) { delay(1000); }
  }

  lcd->init();
  lcd->setRotation(0);
  lcd->fillScreen(TFT_BLACK);

  Serial.printf("Free heap before startup: %u bytes\n",
                (unsigned)ESP.getFreeHeap());

  runStartupSequence();

  drawLogo();
  updateTimer();
  updateStatus();

  Serial.println("Main UI ready.");
}

void loop() {
  handleButtons();

  if (g_running) {
    g_elapsedUs = (uint64_t)esp_timer_get_time() - g_startUs;
    updateTimer();
  }
}

// ============================================================
//  UI functions
// ============================================================
static void drawLogo() {
  lcd->drawBitmap(LOGO_X, LOGO_Y,
                  myLogo, LOGO_W, LOGO_H,
                  TFT_WHITE, TFT_BLACK); // explicit bg clears artifacts
}

// ============================================================
//  Button handling — both buttons now fully debounced
// ============================================================
static void handleButtons() {
  uint32_t now = millis();

  // ── Start/Stop (GPIO 2) ──────────────────────────────────
  bool rawStart = (bool)digitalRead(BTN_START_STOP);
  if (rawStart != g_startBtnLast) g_startDebounce = now;
  if ((now - g_startDebounce) >= DEBOUNCE_MS &&
      rawStart != g_startBtnState) {
    g_startBtnState = rawStart;
    if (g_startBtnState == LOW) doStartStop();
  }
  g_startBtnLast = rawStart;

  // ── Reset / Set Min (GPIO 17) — debounced + hold ─────────
  bool rawReset = (bool)digitalRead(BTN_RESET);

  // Debounce first
  if (rawReset != g_resetBtnLast) g_resetDebounce = now;
  if ((now - g_resetDebounce) >= DEBOUNCE_MS &&
      rawReset != g_resetBtnState) {
    g_resetBtnState = rawReset;

    if (g_resetBtnState == LOW) {
      // Button just pressed (after debounce)
      g_resetHeld    = true;
      g_holdFired    = false;
      g_resetPressAt = now;
    } else {
      // Button just released
      if (g_resetHeld && !g_holdFired) doReset();
      g_resetHeld = false;
      g_holdFired = false;
    }
  }
  g_resetBtnLast = rawReset;

  // Check hold threshold while button is still down
  if (g_resetHeld && !g_holdFired &&
      (now - g_resetPressAt) >= HOLD_MS) {
    g_holdFired = true;
    doSetMin();
  }
}

// ============================================================
//  Timer actions
// ============================================================
static void doStartStop() {
  g_running = !g_running;
  g_showMin = false;
  if (g_running)
    g_startUs = (uint64_t)esp_timer_get_time() - g_elapsedUs;
  updateStatus();
}

static void doReset() {
  g_running   = false;
  g_elapsedUs = 0;
  g_showMin   = false;
  forceFullRedraw();
  updateStatus();
  updateTimer();
}

static void doSetMin() {
  g_running   = false;
  g_elapsedUs = 0;
  g_showMin   = true;
  forceFullRedraw();
  updateStatus();
  updateTimer();
}

static void forceFullRedraw() {
  g_lastSecs      = 0xFFFFFFFF;
  g_lastIntDotLen = -1;
}

// ============================================================
//  Timer display
// ============================================================
static void updateTimer() {
  lcd->setTextSize(TIMER_TS);
  lcd->setTextDatum(TL_DATUM);
  lcd->setTextColor(TFT_WHITE, TFT_BLACK);

  if (g_showMin && !g_running) {
    // Show minimum time constant
    const char* s = "0.00000001";
    int w = 10 * CHAR_W;
    int x = (1024 - w) / 2;
    lcd->fillRect(0, TIMER_TOP, 1024, CHAR_H, TFT_BLACK);
    lcd->drawString(s, x, TIMER_TOP);
    forceFullRedraw();
    return;
  }

  uint32_t secs = (uint32_t)(g_elapsedUs / 1000000ULL);
  uint32_t frac = (uint32_t)(g_elapsedUs % 1000000ULL);

  // intDotBuf e.g. "0."  fracBuf e.g. "00000000" (microseconds + 2 zeros)
  char intDotBuf[16];
  char fracBuf[16];
  snprintf(intDotBuf, sizeof(intDotBuf), "%lu.", (unsigned long)secs);
  snprintf(fracBuf,   sizeof(fracBuf),   "%06lu00", (unsigned long)frac);

  int intDotLen = (int)strlen(intDotBuf);
  int totalW    = (intDotLen + FRAC_DIGITS) * CHAR_W;
  int startX    = (1024 - totalW) / 2;
  int fracX     = startX + intDotLen * CHAR_W;

  if (secs != g_lastSecs || intDotLen != g_lastIntDotLen) {
    // Full redraw when seconds digit count changes
    lcd->fillRect(0, TIMER_TOP, 1024, CHAR_H, TFT_BLACK);
    lcd->drawString(intDotBuf, startX,  TIMER_TOP);
    lcd->drawString(fracBuf,   fracX,   TIMER_TOP);
    g_lastSecs      = secs;
    g_lastIntDotLen = intDotLen;
    g_lastFracX     = fracX;
    return;
  }

  // Partial redraw — fractional part only
  lcd->fillRect(g_lastFracX, TIMER_TOP, FRAC_W, CHAR_H, TFT_BLACK);
  lcd->drawString(fracBuf, g_lastFracX, TIMER_TOP);
}

// ============================================================
//  Status bar
// ============================================================
static void updateStatus() {
  lcd->fillRect(0, STATUS_CY - CHAR_H / 2, 1024, CHAR_H, TFT_BLACK);
  lcd->setTextSize(4);
  lcd->setTextDatum(MC_DATUM);

  if (g_showMin) {
    lcd->setTextColor(TFT_CYAN, TFT_BLACK);
    lcd->drawString("MINIMUM SET", 512, STATUS_CY);
  } else {
    lcd->setTextColor(g_running ? TFT_GREEN : TFT_RED, TFT_BLACK);
    lcd->drawString(g_running ? "RUNNING" : "STOPPED", 512, STATUS_CY);
  }

  lcd->setTextDatum(TL_DATUM); // always reset datum after centered draw
}
